<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project SEKAI - MySekai Xray</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script>
        const SCENES = {
            scene1: {
                physicalWidth: 33.333,
                offsetX: 0,
                offsetY: -40,
                imagePath: "img/grassland.png",
                xDirection: 'x-',
                yDirection: 'y-',
                reverseXY: true,
            },
            scene2: {
                physicalWidth: 24.806,
                offsetX: -62.015,
                offsetY: 20.672,
                imagePath: "img/flowergarden.png",
                xDirection: 'x-',
                yDirection: 'y-',
                reverseXY: true,
            },
            scene3: {
                physicalWidth: 20.513,
                offsetX: 0,
                offsetY: 80,
                imagePath: "img/beach.png",
                xDirection: 'x+',
                yDirection: 'y-',
                reverseXY: false,
            },
            scene4: {
                physicalWidth: 21.333,
                offsetX: 0,
                offsetY: -106.667,
                imagePath: "img/memorialplace.png",
                xDirection: 'x+',
                yDirection: 'y-',
                reverseXY: false,
            }
        };


        const FIXTURE_COLORS = {
            112:  '#f9f9f9',

            1001: '#da6d42', // wood
            1002: '#da6d42',
            1003: '#da6d42',
            1004: '#da6d42',
            
            2001: '#878685', // iron
            2002: '#d5750a', // copper
            2003: '#d5d5d5', // stone
            2004: '#a7c7cb',
            2005: '#9933cc',

            3001: '#c95a49',

            4001: '#f8729a', // flower
            4002: '#f8729a', 
            4003: '#f8729a', 
            4004: '#f8729a',
            4005: '#f8729a',
            4006: '#f8729a',
            4007: '#f8729a',
            4008: '#f8729a',
            4009: '#f8729a', // cotton
            4010: '#f8729a',
            4011: '#f8729a',
            4012: '#f8729a',
            4013: '#f8729a',
            4014: '#f8729a',
            4015: '#f8729a',
            4016: '#f8729a',
            4017: '#f8729a',
            4018: '#f8729a',
            4019: '#f8729a',
            4020: '#f8729a',

            5001: '#f6f5f2',
            5002: '#f6f5f2',
            5003: '#f6f5f2',
            5004: '#f6f5f2',
            5101: '#f6f5f2',
            5102: '#f6f5f2',
            5103: '#f6f5f2',
            5104: '#f6f5f2',

            6001: '#6f4e37',

            7001: '#a5d9ff',
        };

        const ITEM_TEXTURES = {
            mysekai_material: {
                "1": "./icon/Texture2D/item_wood_1.png",
                "2": "./icon/Texture2D/item_wood_2.png",
                "3": "./icon/Texture2D/item_wood_3.png",
                "4": "./icon/Texture2D/item_wood_4.png",
                "5": "./icon/Texture2D/item_wood_5.png",
                "6": "./icon/Texture2D/item_mineral_1.png",
                "7": "./icon/Texture2D/item_mineral_2.png",
                "8": "./icon/Texture2D/item_mineral_3.png",
                "9": "./icon/Texture2D/item_mineral_4.png",
                "10": "./icon/Texture2D/item_mineral_5.png",
                "11": "./icon/Texture2D/item_mineral_6.png",
                "12": "./icon/Texture2D/item_mineral_7.png",
                "13": "./icon/Texture2D/item_junk_1.png",
                "14": "./icon/Texture2D/item_junk_2.png",
                "15": "./icon/Texture2D/item_junk_3.png",
                "16": "./icon/Texture2D/item_junk_4.png",
                "17": "./icon/Texture2D/item_junk_5.png",
                "18": "./icon/Texture2D/item_junk_6.png",
                "19": "./icon/Texture2D/item_junk_7.png",
                "20": "./icon/Texture2D/item_plant_1.png",
                "21": "./icon/Texture2D/item_plant_2.png",
                "22": "./icon/Texture2D/item_plant_3.png",
                "23": "./icon/Texture2D/item_plant_4.png",
                "24": "./icon/Texture2D/item_tone_8.png",
                "32": "./icon/Texture2D/item_junk_8.png",
                "33": "./icon/Texture2D/item_mineral_8.png",
                "34": "./icon/Texture2D/item_junk_9.png",
                "61": "./icon/Texture2D/item_junk_10.png",
                "62": "./icon/Texture2D/item_junk_11.png",
                "63": "./icon/Texture2D/item_junk_12.png",
                "64": "./icon/Texture2D/item_mineral_9.png",
                "65": "./icon/Texture2D/item_mineral_10.png",
            },
            mysekai_item: {
                "7": "./icon/Texture2D/item_blueprint_fragment.png",
            },
            mysekai_fixture: {
                "118": "./icon/Texture2D/mdl_non1001_before_sapling1_118.png",
                "119": "./icon/Texture2D/mdl_non1001_before_sapling1_119.png",
                "120": "./icon/Texture2D/mdl_non1001_before_sapling1_120.png",
                "121": "./icon/Texture2D/mdl_non1001_before_sapling1_121.png",
                "126": "./icon/Texture2D/mdl_non1001_before_sprout1_126.png",
                "127": "./icon/Texture2D/mdl_non1001_before_sprout1_127.png",
                "128": "./icon/Texture2D/mdl_non1001_before_sprout1_128.png",
                "129": "./icon/Texture2D/mdl_non1001_before_sprout1_129.png",
                "130": "./icon/Texture2D/mdl_non1001_before_sprout1_130.png",
                "474": "./icon/Texture2D/mdl_non1001_before_sprout1_474.png",
                "475": "./icon/Texture2D/mdl_non1001_before_sprout1_475.png",
                "476": "./icon/Texture2D/mdl_non1001_before_sprout1_476.png",
                "477": "./icon/Texture2D/mdl_non1001_before_sprout1_477.png",
                "478": "./icon/Texture2D/mdl_non1001_before_sprout1_478.png",
                "479": "./icon/Texture2D/mdl_non1001_before_sprout1_479.png",
                "480": "./icon/Texture2D/mdl_non1001_before_sprout1_480.png",
                "481": "./icon/Texture2D/mdl_non1001_before_sprout1_481.png",
                "482": "./icon/Texture2D/mdl_non1001_before_sprout1_482.png",
                "483": "./icon/Texture2D/mdl_non1001_before_sprout1_483.png"
            },
            mysekai_music_record: {
                "352": "./icon/Texture2D/item_surplus_music_record.png"
            }
        };
        
        const RARE_ITEM = {
            mysekai_material: [5,12,20, 24, 32, 33, 61, 62, 63, 64, 65], 
            mysekai_item: [7], 
            mysekai_music_record: [],
            mysekai_fixture: [118,119,120,121]
        };

        const SUPER_RARE_ITEM = {
            mysekai_material: [5,12,20,24],
            mysekai_item: [],
            mysekai_fixture: [],
            mysekai_music_record: []
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6c5ce7;
            --secondary: #a29bfe;
            --accent: #ff7675;
            --bg: #ffffff;
            --text: #2d3436;
            --border: #e0e0e0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            color: var(--text);
        }

        .container {
            position: relative;
            max-width: 1920px;
            width: 100%;
            text-align: center;
        }

        .image-container {
            position: relative;
            display: inline-block;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s ease;
        }

        .image-container:hover {
            transform: translateY(-5px);
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            display: block;
            border-radius: 12px;
        }

        .grid-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            margin-top: 20px;
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            max-width: 800px;
        }

        .controls label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
            margin-right: 10px;
            display: block;
            margin-bottom: 8px;
        }

        .controls input {
            padding: 8px 12px;
            font-size: 14px;
            width: 100px;
            border: 2px solid var(--border);
            border-radius: 6px;
            transition: border-color 0.3s;
        }

        .controls input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .controls textarea {
            width: 100%;
            height: 100px;
            margin-bottom: 10px;
            padding: 8px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-family: monospace;
            resize: vertical;
        }

        .direction-buttons {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .direction-buttons button,
        .controls button {
            padding: 10px 16px;
            cursor: pointer;
            border: 2px solid var(--border);
            border-radius: 6px;
            background: white;
            color: var(--text);
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .direction-buttons button:hover,
        .controls button:hover {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        .scene-buttons {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .scene-buttons button {
            padding: 12px 16px;
            cursor: pointer;
            font-size: 14px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: white;
            color: var(--text);
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .scene-buttons button:hover {
            border-color: var(--primary);
            transform: translateX(4px);
        }

        .scene-buttons button.active {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            border-color: var(--primary);
            box-shadow: 0 8px 20px rgba(108, 92, 231, 0.3);
        }

        .scene-buttons button.super-rare {
            background: linear-gradient(135deg, #e84393 0%, #fd79a8 100%);
            color: white;
            border-color: #e84393;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .log-container {
            width: 100%;
            max-width: 700px;
            height: 150px;
            border: 2px solid var(--border);
            padding: 12px;
            margin: 15px 0;
            overflow-y: auto;
            background-color: #f9f9f9;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            text-align: left;
            border-radius: 8px;
        }

        .log-entry {
            margin-bottom: 5px;
            line-height: 1.4;
        }

        .log-entry .timestamp {
            color: var(--primary);
            margin-right: 10px;
            font-weight: 500;
        }

        .log-entry .message {
            color: var(--text);
        }

        .item-list {
            position: absolute;
            background: rgba(108, 92, 231, 0.85);
            border-radius: 8px;
            font-size: 12px;
            text-align: left;
            padding: 4px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .item-list img {
            width: 20px;
            height: 20px;
            vertical-align: middle;
            position: relative;
            margin: 2px;
        }

        .item-list .quantity {
            font-size: 8px;
            position: absolute;
            bottom: 0;
            right: 0;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            padding: 2px 4px;
            font-weight: bold;
            pointer-events: none;
        }

        details {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid var(--border);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            color: var(--primary);
            padding: 8px;
            user-select: none;
        }

        summary:hover {
            background: #f0f0f0;
            border-radius: 6px;
        }

        .filter-button {
            padding: 10px 16px;
            cursor: pointer;
            border: 2px solid var(--border);
            border-radius: 6px;
            background: white;
            color: var(--text);
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
            width: 100%;
            margin-top: 15px;
        }

        .filter-button:hover {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }

        .action-buttons button {
            flex: 1;
            padding: 10px 16px;
            cursor: pointer;
            border: 2px solid var(--border);
            border-radius: 6px;
            background: white;
            color: var(--text);
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .action-buttons button:hover {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
        }

        .filter-panel {
            display: none;
            margin-top: 15px;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: #f9f9f9;
            max-height: 400px;
            overflow-y: auto;
        }

        .filter-panel.active {
            display: block;
        }

        .filter-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .filter-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-option input[type="radio"] {
            cursor: pointer;
        }

        .filter-option label {
            cursor: pointer;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .item-checkbox-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: white;
            border-radius: 6px;
        }

        .item-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .item-checkbox input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .item-checkbox label {
            cursor: pointer;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
        }

        .item-checkbox img {
            width: 36px;
            height: 36px;
        }

        .item-preview {
            display: none;
            position: fixed;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            pointer-events: none;
        }

        .item-preview.active {
            display: block;
        }

        .item-preview img {
            width: 120px;
            height: 120px;
            object-fit: contain;
        }

        .item-preview-name {
            font-size: 12px;
            font-weight: 500;
            margin-top: 8px;
            text-align: center;
            color: var(--text);
        }

        .menu-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
        }

        .menu-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(108, 92, 231, 0.4);
        }

        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 320px;
            height: 100vh;
            background: white;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 999;
            overflow-y: auto;
            padding: 20px;
        }

        .sidebar.active {
            transform: translateX(0);
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .sidebar-header h2 {
            margin: 0;
            font-size: 18px;
            color: var(--text);
        }

        .sidebar-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .sidebar-close:hover {
            color: var(--primary);
            transform: rotate(90deg);
        }

        .sidebar-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .sidebar-content .scene-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sidebar-content .scene-buttons button {
            padding: 12px;
            text-align: left;
            font-size: 14px;
        }

        .sidebar-content .filter-button,
        .sidebar-content .action-buttons {
            width: 100%;
        }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 998;
        }

        .sidebar-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .controls {
            display: none;
        }

        .drop-zone-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5000;
            transition: opacity 0.3s ease;
        }

        .drop-zone-backdrop.hidden {
            display: none;
        }

        .drop-zone {
            position: relative;
            background: white;
            border-radius: 12px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px dashed var(--border);
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            border-color: var(--primary);
            background: rgba(108, 92, 231, 0.05);
            transform: scale(1.02);
        }

        .drop-zone-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .drop-zone-close:hover {
            color: var(--primary);
            transform: rotate(90deg);
        }

        .drop-zone-content {
            text-align: center;
            color: var(--text);
            pointer-events: none;
        }

        .drop-zone-content h2 {
            font-size: 24px;
            margin-bottom: 15px;
            font-weight: 600;
            color: var(--text);
        }

        .drop-zone-content .drop-hint {
            font-size: 16px;
            margin-bottom: 25px;
            opacity: 0.8;
            color: var(--text);
        }

        .drop-zone-content .drop-icon {
            font-size: 60px;
            margin-bottom: 15px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .drop-zone-content .or-text {
            font-size: 13px;
            opacity: 0.6;
            margin: 15px 0;
            color: var(--text);
        }

        .drop-zone-content .file-input-button {
            margin-top: 15px;
            padding: 10px 24px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: all;
        }

        .drop-zone-content .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(108, 92, 231, 0.3);
        }

        #hiddenFileInput {
            display: none;
        }

        .data-loaded-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #06c755 0%, #34c847 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(6, 199, 85, 0.3);
            animation: slideIn 0.4s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .data-error-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff7675 0%, #ff4757 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(255, 70, 87, 0.3);
            animation: slideIn 0.4s ease;
        }
    </style>
</head>
<body>
    <!-- Drop Zone Modal -->
    <div class="drop-zone-backdrop hidden" id="dropZoneBackdrop">
        <div class="drop-zone" id="dropZone">
            <button class="drop-zone-close" onclick="closeDropZoneModal()">‚úï</button>
            <div class="drop-zone-content">
                <div class="drop-icon">üìÅ</div>
                <h2>Load Data File</h2>
                <div class="drop-hint">Drag & drop your JSON file here</div>
                <div class="or-text">or</div>
                <button class="file-input-button" onclick="document.getElementById('hiddenFileInput').click()">
                    Browse Files
                </button>
            </div>
        </div>
    </div>
    <input type="file" id="hiddenFileInput" />

    <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
    <div class="sidebar-overlay" onclick="closeSidebar()" id="sidebarOverlay"></div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2>Controls</h2>
            <button class="sidebar-close" onclick="closeSidebar()">‚úï</button>
        </div>
        <div class="sidebar-content" id="sidebarContent">
        </div>
    </div>

    <div class="container">
        <div class="image-container">
            <img src="image.png" alt="Example image" id="image">
            <canvas class="grid-canvas" id="gridCanvas"></canvas>
        </div>
    </div>

    <div class="controls">
        <div class="scene-buttons">
            <button onclick="selectScene('scene1')" data-scene="scene1">„Åï„ÅÑ„Åó„Çá„ÅÆÂéü„Å£„Å±</button>
            <button onclick="selectScene('scene2')" data-scene="scene2">ÂΩ©„Çä„ÅÆËä±Áïë</button>
            <button onclick="selectScene('scene3')" data-scene="scene3">È°ò„ÅÑ„ÅÆÁ†ÇÊµú</button>
            <button onclick="selectScene('scene4')" data-scene="scene4">Âøò„ÇåÂéª„Çâ„Çå„ÅüÂ†¥ÊâÄ</button>
        </div>
        <br>
        <button class="filter-button" onclick="openDropZoneModal()">üì§ Load Data File</button>
        <button class="filter-button" onclick="toggleFilterPanel()">üîç Filter Items</button>


        <div class="filter-panel" id="filterPanel">
            <div class="filter-options">
                <div class="filter-option">
                    <input type="radio" id="filterAll" name="filterMode" value="all" checked onchange="changeFilterMode()">
                    <label for="filterAll">Show All Items</label>
                </div>
                <div class="filter-option">
                    <input type="radio" id="filterRare" name="filterMode" value="rare" onchange="changeFilterMode()">
                    <label for="filterRare">Show Rare Items Only</label>
                </div>
                <div class="filter-option">
                    <input type="radio" id="filterCustom" name="filterMode" value="custom" onchange="changeFilterMode()">
                    <label for="filterCustom">Show Custom Selected Items</label>
                </div>
            </div>
            <div id="itemCheckboxContainer" class="item-checkbox-list"></div>
        </div>
        <br><br>
        <div class="log-container" id="logContainer"></div>
        <br>
        <details>
            <summary>Advance Settings</summary>
            <label for="physicalWidth">Grid Width(px):</label>
            <input type="number" id="physicalWidth" value="10" min="1" step="1">
            <label for="offsetX">X Offset(px):</label>
            <input type="number" id="offsetX" value="0" step="1">
            <label for="offsetY">Y Offset(px):</label>
            <input type="number" id="offsetY" value="0" step="1">
            <button onclick="drawGrid()">Draw Grid</button>
            <button onclick="clearGrid()">Clear Canvas</button>
            <br>
            <div class="direction-buttons">
                <button onclick="setDirection('x+', 'y+')">X+ Y+</button>
                <button onclick="setDirection('x+', 'y-')">X+ Y-</button>
                <button onclick="setDirection('x-', 'y+')">X- Y+</button>
                <button onclick="setDirection('x-', 'y-')">X- Y-</button>
            </div>
        </details>
    </div>

    <script>
        let xDirection = 'x+';
        let yDirection = 'y-';
        let reverseXY = false;
        let currentScene = 'scene1';
        let harvestData = {};
        let lastUpdateTime = 0;

        // Filter variables
        let filterMode = 'all'; // 'all', 'rare', 'custom'
        let selectedItems = new Set(); // Set of user-selected item IDs
        let itemPreview = null; // Item preview element

        // Log messages to UI
        function logger(message) {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';

            const timestamp = document.createElement('span');
            timestamp.className = 'timestamp';
            const now = new Date();
            timestamp.textContent = `[${now.toLocaleString()}]`;

            const messageSpan = document.createElement('span');
            messageSpan.className = 'message';
            messageSpan.textContent = message;

            logEntry.appendChild(timestamp);
            logEntry.appendChild(messageSpan);
            logContainer.appendChild(logEntry);

            // Auto-scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Scene ID mapping
        const SITE_ID_MAP = {
            1: "„Éû„Ç§„Éõ„Éº„É†",
            2: "1F",
            3: "2F",
            4: "3F",
            5: "„Åï„ÅÑ„Åó„Çá„ÅÆÂéü„Å£„Å±",
            6: "È°ò„ÅÑ„ÅÆÁ†ÇÊµú",
            7: "ÂΩ©„Çä„ÅÆËä±Áïë",
            8: "Âøò„ÇåÂéª„Çâ„Çå„ÅüÂ†¥ÊâÄ",
        };

        // Parse harvest map data from game API response
        function parseMapData(gameData) {
            if (!gameData) {
                logger('Error: gameData is null');
                return {};
            }

            if (!gameData.updatedResources) {
                logger('Warning: updatedResources not found');
                return {};
            }

            if (!gameData.updatedResources.userMysekaiHarvestMaps) {
                logger('Warning: userMysekaiHarvestMaps not found');
                return {};
            }

            const harvestMaps = gameData.updatedResources.userMysekaiHarvestMaps;
            logger(`Found ${harvestMaps.length} scenes`);

            const processedMap = {};

            harvestMaps.forEach((mp) => {
                const siteId = mp.mysekaiSiteId;
                const siteName = SITE_ID_MAP[siteId] || `Unknown Site ${siteId}`;

                const mpDetail = [];
                const fixtures = mp.userMysekaiSiteHarvestFixtures || [];
                const drops = mp.userMysekaiSiteHarvestResourceDrops || [];

                // Collect all spawned fixtures
                let spawnedCount = 0;
                fixtures.forEach(fixture => {
                    if (fixture.userMysekaiSiteHarvestFixtureStatus === "spawned") {
                        mpDetail.push({
                            location: [fixture.positionX, fixture.positionZ],
                            fixtureId: fixture.mysekaiSiteHarvestFixtureId,
                            reward: {}
                        });
                        spawnedCount++;
                    }
                });

                // Add drop items to fixtures
                drops.forEach(drop => {
                    const pos = [drop.positionX, drop.positionZ];
                    const found = mpDetail.find(item =>
                        item.location[0] === pos[0] && item.location[1] === pos[1]
                    );

                    if (found) {
                        if (!found.reward[drop.resourceType]) {
                            found.reward[drop.resourceType] = {};
                        }
                        found.reward[drop.resourceType][drop.resourceId] =
                            (found.reward[drop.resourceType][drop.resourceId] || 0) + drop.quantity;
                    }
                });

                processedMap[siteName] = mpDetail;
                logger(`Scene "${siteName}" loaded: ${spawnedCount} fixtures`);
            });

            return processedMap;
        }

        // Load data from local mysekai_data.json file
        async function loadLocalData() {
            logger('Loading mysekai_data.json...');
            try {
                const response = await fetch('mysekai_data.json');

                if (!response.ok) {
                    throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
                }

                const gameData = await response.json();

                harvestData = parseMapData(gameData);
                lastUpdateTime = Date.now() / 1000;

                const sceneNames = Object.keys(harvestData);
                if (sceneNames.length === 0) {
                    logger('Warning: No scene data loaded');
                } else {
                    logger('Data loaded: ' + sceneNames.join(', '));
                }

                // Update button states
                updateSceneButtonStatus();

                // Auto-mark points on current scene
                parseAndMarkPoints();
            } catch (error) {
                logger('Error loading data: ' + error.message);
            }
        }

        // Server polling (deprecated - using local mode now)
        async function pollServer() {
            // Local mode: single load, no polling needed
        }

        // Update scene buttons with super rare item indicator
        function updateSceneButtonStatus() {
            const sceneNameMap = {
                'scene1': '„Åï„ÅÑ„Åó„Çá„ÅÆÂéü„Å£„Å±',
                'scene2': 'ÂΩ©„Çä„ÅÆËä±Áïë',
                'scene3': 'È°ò„ÅÑ„ÅÆÁ†ÇÊµú',
                'scene4': 'Âøò„ÇåÂéª„Çâ„Çå„ÅüÂ†¥ÊâÄ'
            };

            for (const sceneKey in sceneNameMap) {
                const sceneName = sceneNameMap[sceneKey];
                const points = harvestData[sceneName];
                const button = document.querySelector(`button[data-scene="${sceneKey}"]`);

                if (!button) continue;

                // Remove previous super-rare styling
                button.classList.remove('super-rare');

                if (points && Array.isArray(points)) {
                    // Check if scene has super rare items
                    const hasSuperRare = points.some(point => {
                        return doContainsRareItem(point.reward, true);
                    });

                    if (hasSuperRare) {
                        button.classList.add('super-rare');
                        logger(`Scene ${sceneName} has super rare items!`);
                    }
                }
            }
        }

        function selectScene(sceneKey) {
            currentScene = sceneKey;
            const selectedScene = SCENES[sceneKey];

            if (selectedScene) {
                // Update button state
                document.querySelectorAll('.scene-buttons button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`button[data-scene="${sceneKey}"]`).classList.add('active');

                physicalWidthInput.value = selectedScene.physicalWidth;
                offsetXInput.value = selectedScene.offsetX;
                offsetYInput.value = selectedScene.offsetY;
                xDirection = selectedScene.xDirection;
                yDirection = selectedScene.yDirection;
                reverseXY = selectedScene.reverseXY;

                logger(`Scene changed: ${sceneKey}`);

                // Set image path and wait for loading to complete
                image.src = selectedScene.imagePath;

                // Wait for image loading before initializing canvas and drawing
                if (image.complete) {
                    initCanvas();
                    parseAndMarkPoints();
                } else {
                    image.onload = () => {
                        initCanvas();
                        parseAndMarkPoints();
                    };
                }
            } else {
                logger(`Scene not found: ${sceneKey}`);
            }
        }

        const image = document.getElementById('image');
        const canvas = document.getElementById('gridCanvas');
        const physicalWidthInput = document.getElementById('physicalWidth');
        const offsetXInput = document.getElementById('offsetX');
        const offsetYInput = document.getElementById('offsetY');
        let ctx = canvas.getContext('2d');

        function initCanvas() {
            canvas.width = image.clientWidth;
            canvas.height = image.clientHeight;
        }

        // Re-initialize canvas and redraw when window is resized
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                initCanvas();
                parseAndMarkPoints();
            }, 250);
        });

        function drawGrid() {
            const physicalGridWidth = parseFloat(physicalWidthInput.value);
            const offsetX = parseFloat(offsetXInput.value);
            const offsetY = parseFloat(offsetYInput.value);
            const displayWidth = image.clientWidth;
            const displayHeight = image.clientHeight;
            const naturalWidth = image.naturalWidth;
            const naturalHeight = image.naturalHeight;

            const scaleX = displayWidth / naturalWidth;
            const scaleY = displayHeight / naturalHeight;

            const displayGridWidth = physicalGridWidth * scaleX;

            const originX = displayWidth / 2 + offsetX;
            const originY = displayHeight / 2 + offsetY;

            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 1;

            for (let y = originY; y >= 0; y -= displayGridWidth) {
                drawHorizontalLine(y);
            }
            for (let y = originY + displayGridWidth; y <= displayHeight; y += displayGridWidth) {
                drawHorizontalLine(y);
            }

            for (let x = originX; x >= 0; x -= displayGridWidth) {
                drawVerticalLine(x);
            }
            for (let x = originX + displayGridWidth; x <= displayWidth; x += displayGridWidth) {
                drawVerticalLine(x);
            }

            drawCoordinateAxes(originX, originY);
        }

        function drawHorizontalLine(y) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        function drawVerticalLine(x) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        function drawCoordinateAxes(originX, originY) {
            const crossSize = 3;

            ctx.strokeStyle = 'black';
            ctx.beginPath();
            ctx.moveTo(originX - crossSize, originY - crossSize);
            ctx.lineTo(originX + crossSize, originY + crossSize);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(originX + crossSize, originY - crossSize);
            ctx.lineTo(originX - crossSize, originY + crossSize);
            ctx.stroke();
        }

        function parseAndMarkPoints() {
            try {
                // Scene name mapping
                const sceneNameMap = {
                    'scene1': '„Åï„ÅÑ„Åó„Çá„ÅÆÂéü„Å£„Å±',
                    'scene2': 'ÂΩ©„Çä„ÅÆËä±Áïë',
                    'scene3': 'È°ò„ÅÑ„ÅÆÁ†ÇÊµú',
                    'scene4': 'Âøò„ÇåÂéª„Çâ„Çå„ÅüÂ†¥ÊâÄ'
                };

                const sceneName = sceneNameMap[currentScene];
                const points = harvestData[sceneName];

                // Clear canvas and items
                initCanvas();
                clearItemLists();

                if (!points) {
                    logger(`Scene ${sceneName} has no data`);
                    return;
                }

                if (!Array.isArray(points)) {
                    logger("Error: Data is not an array");
                    return;
                }

                if (!reverseXY) {
                    points.forEach(point => markPoint(point));
                } else {
                    points.forEach(point => markPoint({location: [point.location[1], point.location[0]], fixtureId: point.fixtureId, reward: point.reward}));
                }

                // Adjust item list positions to avoid overlap
                adjustItemListPositions(5, 5);
                logger(`Marked ${points.length} fixtures`);
            } catch (error) {
                logger("Error marking points: " + error.message);
            }
        }

        function doContainsRareItem(reward, isSuperRare = false) {
            let compareList = isSuperRare ? SUPER_RARE_ITEM : RARE_ITEM;
            for (const category in reward) {
                if (reward.hasOwnProperty(category) && compareList.hasOwnProperty(category)) {
                    for (const itemId of Object.keys(reward[category])) {
                        if (compareList[category].includes(parseInt(itemId))) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function markPoint(point) {
            const [x, y] = point.location;
            const offsetX = parseFloat(offsetXInput.value);
            const offsetY = parseFloat(offsetYInput.value);
            const originX = canvas.width / 2 + offsetX;
            const originY = canvas.height / 2 + offsetY;
            const displayGridWidth = parseFloat(physicalWidthInput.value) * (image.clientWidth / image.naturalWidth);

            const displayX = xDirection === 'x+' ? originX + x * displayGridWidth : originX - x * displayGridWidth;
            const displayY = yDirection === 'y+' ? originY + y * displayGridWidth : originY - y * displayGridWidth;

            // Check if this location has items user wants to see
            let hasVisibleItems = false;
            for (const category in point.reward) {
                if (!point.reward.hasOwnProperty(category)) continue;
                for (const itemId in point.reward[category]) {
                    if (!point.reward[category].hasOwnProperty(itemId)) continue;
                    if (shouldShowItem(category, itemId)) {
                        hasVisibleItems = true;
                        break;
                    }
                }
                if (hasVisibleItems) break;
            }

            // If no visible items and not showing all, skip this point
            if (!hasVisibleItems && filterMode !== 'all') {
                return;
            }

            const color = FIXTURE_COLORS[point.fixtureId];

            let ifContainRareItem = false;
            if (color) {
                // Draw point
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(displayX, displayY, 5, 0, Math.PI * 2);
                ctx.fill();

                const containsRareItem = doContainsRareItem(point.reward);
                if (containsRareItem) {
                    // Draw red border
                    ctx.strokeStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(displayX, displayY, 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ifContainRareItem = true;
                } else {
                    // Draw black border
                    ctx.strokeStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(displayX, displayY, 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                displayReward(point.reward, displayX + displayGridWidth * 0.6, displayY + displayGridWidth * 0.4, ifContainRareItem);

            } else {
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText('?', displayX - 3, displayY + 4);
            }
        }


        function displayReward(reward, x, y, ifContainRareItem) {
            const itemList = document.createElement('div');
            itemList.className = 'item-list';

            let hasVisibleItems = false;

            for (const category in reward) {
                if (!reward.hasOwnProperty(category)) continue;
                for (const itemId in reward[category]) {
                    if (!reward[category].hasOwnProperty(itemId)) continue;

                    // Check if this item should be displayed
                    if (!shouldShowItem(category, itemId)) {
                        continue;
                    }

                    hasVisibleItems = true;
                    const quantity = reward[category][itemId];
                    const texture = ITEM_TEXTURES[category]?.[itemId] || './icon/missing.png';

                    const itemEntry = document.createElement('div');
                    const itemImage = document.createElement('img');

                    if (category == "mysekai_music_record") {
                        itemImage.src = './icon/Texture2D/item_surplus_music_record.png';
                    } else {
                        itemImage.src = texture;
                    }

                    itemImage.style.cursor = 'pointer';
                    itemImage.onmouseover = (e) => {
                        showItemPreview(itemImage.src, `${category} #${itemId}`, e.clientX, e.clientY);
                    };
                    itemImage.onmousemove = (e) => {
                        const preview = itemPreview;
                        if (preview && preview.classList.contains('active')) {
                            preview.style.left = (e.clientX + 15) + 'px';
                            preview.style.top = (e.clientY + 15) + 'px';
                        }
                    };
                    itemImage.onmouseout = () => {
                        hideItemPreview();
                    };

                    const quantityBadge = document.createElement('span');
                    quantityBadge.className = 'quantity';
                    quantityBadge.textContent = quantity;

                    itemEntry.style.position = 'relative';
                    itemEntry.appendChild(itemImage);
                    itemEntry.appendChild(quantityBadge);
                    if (reverseXY) {
                        itemEntry.style.display = "inline-block"; // Horizontal layout
                    }

                    itemList.appendChild(itemEntry);
                }
            }

            // If no visible items, don't show item card
            if (!hasVisibleItems) {
                return;
            }

            if (ifContainRareItem || reward.hasOwnProperty("mysekai_music_record")) {
                if (doContainsRareItem(reward, true)) {
                    itemList.style.background = 'rgba(255, 0, 0, 0.85)';
                } else {
                    itemList.style.background = 'rgba(162, 155, 254, 0.85)';
                }
            }

            const imageContainer = document.querySelector('.image-container');
            imageContainer.appendChild(itemList);

            // Delay boundary detection to wait for DOM rendering to complete
            setTimeout(() => {
                const imageContainer = document.querySelector('.image-container');
                const containerWidth = imageContainer.offsetWidth;
                const containerHeight = imageContainer.offsetHeight;
                const itemRect = itemList.getBoundingClientRect();
                const containerRect = imageContainer.getBoundingClientRect();

                let finalLeft = x;
                let finalTop = y;
                const itemWidth = itemRect.width;
                const itemHeight = itemRect.height;
                const margin = 5;

                // Check if exceeds right boundary
                if (x + itemWidth + margin > containerWidth) {
                    finalLeft = Math.max(0, containerWidth - itemWidth - margin);
                }

                // Check if exceeds bottom boundary
                if (y + itemHeight + margin > containerHeight) {
                    finalTop = Math.max(0, containerHeight - itemHeight - margin);
                }

                // Check if exceeds top boundary
                if (finalTop < 0) {
                    finalTop = margin;
                }

                // Check if exceeds left boundary
                if (finalLeft < 0) {
                    finalLeft = margin;
                }

                if (reverseXY) {
                    itemList.style.left = `${finalLeft}px`;
                    itemList.style.top = `${finalTop - 10}px`;
                } else {
                    itemList.style.left = `${finalLeft}px`;
                    itemList.style.top = `${finalTop}px`;
                }
            }, 0);
        }

        function adjustItemListPositions(maxLapWidth, maxLapHeight) {
            const itemLists = Array.from(document.querySelectorAll('.item-list'));

            for (let i = 0; i < itemLists.length; i++) {
                const rect1 = itemLists[i].getBoundingClientRect();

                for (let j = i; j < itemLists.length; j++) {
                    if (i === j) continue;

                    const rect2 = itemLists[j].getBoundingClientRect();

                    // Check for overlaps exceeding threshold
                    const overlapWidth = Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left);
                    const overlapHeight = Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top);

                    if (overlapWidth > 0 && overlapHeight > 0 && (overlapWidth > maxLapWidth || overlapHeight > maxLapHeight)) {
                        if (reverseXY) {
                            const currentTop = parseFloat(itemLists[j].style.top || 0);
                            itemLists[j].style.top = `${currentTop - overlapHeight / 1.25}px`;
                        } else {
                            const currentLeft = parseFloat(itemLists[j].style.left || 0);
                            itemLists[j].style.left = `${currentLeft - overlapWidth / 1.25}px`;
                        }
                    }
                }
            }
        }

        function setDirection(newXDirection, newYDirection) {
            xDirection = newXDirection;
            yDirection = newYDirection;
            parseAndMarkPoints();
        }
       
        function clearItemLists() {
            // Remove all item lists from page
            document.querySelectorAll('.item-list').forEach(item => item.remove());
        }

        function clearGrid() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Also clear item lists
            clearItemLists();
        }

        // Filter functions
        function toggleFilterPanel() {
            const filterPanel = document.getElementById('filterPanel');
            filterPanel.classList.toggle('active');
            if (filterPanel.classList.contains('active')) {
                initializeItemCheckboxes();
            }
        }

        function changeFilterMode() {
            const selected = document.querySelector('input[name="filterMode"]:checked');
            filterMode = selected.value;
            const customCheckboxes = document.getElementById('itemCheckboxContainer');

            if (filterMode === 'custom') {
                customCheckboxes.style.display = 'grid';
            } else {
                customCheckboxes.style.display = 'none';
            }

            parseAndMarkPoints();
        }

        function initializeItemCheckboxes() {
            const container = document.getElementById('itemCheckboxContainer');
            if (container.children.length > 0) return; // Already initialized

            const allItems = [];

            // Collect all items
            for (const category in ITEM_TEXTURES) {
                for (const itemId in ITEM_TEXTURES[category]) {
                    allItems.push({ category, itemId, path: ITEM_TEXTURES[category][itemId] });
                }
            }

            // Create checkboxes
            allItems.forEach(item => {
                const checkbox = document.createElement('div');
                checkbox.className = 'item-checkbox';

                const inputId = `item-${item.category}-${item.itemId}`;
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = inputId;
                input.value = `${item.category}:${item.itemId}`;
                input.onchange = (e) => {
                    if (e.target.checked) {
                        selectedItems.add(e.target.value);
                    } else {
                        selectedItems.delete(e.target.value);
                    }
                    parseAndMarkPoints();
                };

                const label = document.createElement('label');
                label.htmlFor = inputId;

                const img = document.createElement('img');
                img.src = item.path;
                img.onerror = function() { this.style.display = 'none'; };

                label.appendChild(img);

                checkbox.appendChild(input);
                checkbox.appendChild(label);
                container.appendChild(checkbox);
            });

            // Hide checkbox container by default
            if (filterMode !== 'custom') {
                container.style.display = 'none';
            }
        }

        function shouldShowItem(category, itemId) {
            if (filterMode === 'all') {
                return true;
            } else if (filterMode === 'rare') {
                const rareItems = RARE_ITEM[category] || [];
                return rareItems.includes(parseInt(itemId));
            } else if (filterMode === 'custom') {
                return selectedItems.has(`${category}:${itemId}`);
            }
            return true;
        }

        // Initialize item preview
        function createItemPreview() {
            if (!itemPreview) {
                itemPreview = document.createElement('div');
                itemPreview.className = 'item-preview';
                document.body.appendChild(itemPreview);
            }
            return itemPreview;
        }

        function showItemPreview(imgSrc, itemName, mouseX, mouseY) {
            const preview = createItemPreview();
            preview.innerHTML = `<img src="${imgSrc}" onerror="this.style.display='none'">`;
            preview.classList.add('active');
            preview.style.left = (mouseX + 15) + 'px';
            preview.style.top = (mouseY + 15) + 'px';
        }

        function hideItemPreview() {
            if (itemPreview) {
                itemPreview.classList.remove('active');
            }
        }

        // Sidebar functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const menuToggle = document.querySelector('.menu-toggle');
            sidebar.classList.toggle('active');
            overlay.classList.toggle('active');
            menuToggle.style.display = sidebar.classList.contains('active') ? 'none' : 'flex';
        }

        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const menuToggle = document.querySelector('.menu-toggle');
            sidebar.classList.remove('active');
            overlay.classList.remove('active');
            menuToggle.style.display = 'flex';
        }

        function initializeSidebar() {
            const sidebarContent = document.getElementById('sidebarContent');
            const controlsDiv = document.querySelector('.controls');

            if (sidebarContent.innerHTML.trim() === '') {
                sidebarContent.innerHTML = controlsDiv.innerHTML;
            }
        }

        // Drop Zone and File Upload Functions
        let dataLoadedFromFile = false;

        function openDropZoneModal() {
            const backdrop = document.getElementById('dropZoneBackdrop');
            backdrop.classList.remove('hidden');
        }

        function closeDropZoneModal() {
            const backdrop = document.getElementById('dropZoneBackdrop');
            backdrop.classList.add('hidden');
        }

        function showDataLoadedIndicator(fileName) {
            const indicator = document.createElement('div');
            indicator.className = 'data-loaded-indicator';
            indicator.textContent = `‚úì Loaded: ${fileName}`;
            document.body.appendChild(indicator);
            setTimeout(() => indicator.remove(), 3000);
        }

        function showDataErrorIndicator(message) {
            const indicator = document.createElement('div');
            indicator.className = 'data-error-indicator';
            indicator.textContent = `‚úó Error: ${message}`;
            document.body.appendChild(indicator);
            setTimeout(() => indicator.remove(), 4000);
        }

        function processJsonFile(content, fileName) {
            try {
                const gameData = JSON.parse(content);
                harvestData = parseMapData(gameData);
                lastUpdateTime = Date.now() / 1000;

                const sceneNames = Object.keys(harvestData);
                if (sceneNames.length === 0) {
                    logger('Warning: No scene data in file');
                    showDataErrorIndicator('No valid scene data found');
                    return false;
                }

                logger(`Data loaded from file: ${fileName}`);
                logger('Data loaded: ' + sceneNames.join(', '));
                updateSceneButtonStatus();
                parseAndMarkPoints();
                closeDropZoneModal();
                showDataLoadedIndicator(fileName);
                dataLoadedFromFile = true;
                return true;
            } catch (error) {
                logger('Error parsing JSON: ' + error.message);
                showDataErrorIndicator('Invalid JSON format');
                return false;
            }
        }

        function handleFileUpload(file) {
            const reader = new FileReader();

            reader.onload = (e) => {
                const content = e.target.result;
                processJsonFile(content, file.name);
            };

            reader.onerror = () => {
                logger('Error reading file');
                showDataErrorIndicator('Failed to read file');
            };

            reader.readAsText(file);
        }

        function initializeDropZone() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('hiddenFileInput');
            const backdrop = document.getElementById('dropZoneBackdrop');

            // Drag and drop events
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });

            // Close modal when clicking outside
            backdrop.addEventListener('click', (e) => {
                if (e.target === backdrop) {
                    closeDropZoneModal();
                }
            });

            // Prevent default drag behavior on body
            document.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            document.addEventListener('drop', (e) => {
                e.preventDefault();
            });
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            logger('Page loaded. Please load a data file to continue.');
            initializeSidebar();
            initializeDropZone();

            // Wait for image loading before initializing canvas
            if (image.complete) {
                // Image is already cached
                initCanvas();
            } else {
                // Wait for image loading
                image.addEventListener('load', () => {
                    initCanvas();
                });
            }
            selectScene('scene1');

            // Show upload modal on page load
            openDropZoneModal();
        });
    </script>
</body>
</html>
